#!/bin/bash
set -e

# Usage: create-handoff [--safe] <session_id>

SAFE_MODE=false
SESSION_ID=""
USER_MESSAGE=""
KEEP_MSGS=""

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --safe)
            SAFE_MODE=true
            shift
            ;;
        -m|--message)
            USER_MESSAGE="$2"
            shift 2
            ;;
        -k|--keep)
            KEEP_MSGS="$2"
            shift 2
            ;;
        -h|--help)
            echo "Usage: create-handoff [options] <session_id>"
            echo "       create-handoff --list"
            echo ""
            echo "Options:"
            echo "  -k, --keep <N>       Keep last N assistant messages (default: 15)"
            echo "  -m, --message <msg>  Append a message to the resume prompt"
            echo "  --list               List recent sessions across all projects"
            echo "  --safe               Run without --dangerously-skip-permissions"
            echo "  -h, --help           Show this help message"
            exit 0
            ;;
        --list)
            echo "Recent sessions:"
            echo ""
            find "$HOME/.claude/projects" -name "*.jsonl" -type f -print0 2>/dev/null | \
                xargs -0 ls -lt 2>/dev/null | \
                head -20 | \
                while read -r line; do
                    # Extract filename and get session ID (basename without .jsonl)
                    filepath=$(echo "$line" | awk '{print $NF}')
                    session_id=$(basename "$filepath" .jsonl)
                    mod_date=$(echo "$line" | awk '{print $6, $7, $8}')
                    # Extract project dir from path
                    project_dir=$(dirname "$filepath" | xargs basename)
                    printf "%-38s  %-20s  %s\n" "$session_id" "$mod_date" "$project_dir"
                done
            exit 0
            ;;
        *)
            SESSION_ID="$1"
            shift
            ;;
    esac
done

if [ -z "$SESSION_ID" ]; then
    echo "Usage: create-handoff [--safe] <session_id>"
    exit 1
fi

# Find session file across all projects
SESSION_FILE=$(find "$HOME/.claude/projects" -name "${SESSION_ID}.jsonl" 2>/dev/null | head -1)

if [ -z "$SESSION_FILE" ]; then
    echo "Session not found: $SESSION_ID"
    echo ""
    echo "Hint: Use 'create-handoff --list' to see available sessions"
    exit 1
fi

# Generate timestamp for handoff filename
TIMESTAMP=$(date +%Y-%m-%d_%H-%M-%S)
HANDOFF_DIR="thoughts/shared/handoffs/general"
HANDOFF_FILE="$HANDOFF_DIR/${TIMESTAMP}_session-handoff.md"

# Ensure handoff directory exists
mkdir -p "$HANDOFF_DIR"

# Resolve script location (follow symlinks)
SCRIPT_PATH="$0"
if [ -L "$SCRIPT_PATH" ]; then
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
fi
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# Create temp files
TEMP_PROMPT=$(mktemp)
TEMP_SESSION=$(mktemp)
trap "rm -f $TEMP_PROMPT $TEMP_SESSION" EXIT

# Prune session to last N assistant messages (like claude-prune)
# This keeps complete message exchanges and stays under context limit
MAX_ASSISTANT_MSGS=${KEEP_MSGS:-15}

node -e '
const fs = require("fs");
const lines = fs.readFileSync(process.argv[1], "utf8").trim().split("\n");
let keep = parseInt(process.argv[2], 10);

const MSG_TYPES = new Set(["user", "assistant", "system"]);
const MAX_OUTPUT_BYTES = 100000; // ~25K tokens target
const MIN_MESSAGES = 5;

// Clear large content blocks to reduce context size
// Per Anthropic guidance: old tool results are not needed for understanding what happened
function clearLargeContent(msgObj) {
  // Helper to clear blocks in an array
  function clearBlocks(arr) {
    return arr.map(block => {
      if (block.type === "tool_result") {
        return { ...block, content: "[cleared]" };
      }
      if (block.type === "document") {
        return { type: "text", text: "[document cleared]" };
      }
      return block;
    });
  }

  // Handle message.content array (common structure)
  if (msgObj.message && msgObj.message.content && Array.isArray(msgObj.message.content)) {
    msgObj.message.content = clearBlocks(msgObj.message.content);
  }
  // Handle message as direct array (alternate structure)
  if (Array.isArray(msgObj.message)) {
    msgObj.message = clearBlocks(msgObj.message);
  }
  // Clear toolUseResult with file data (base64 encoded files)
  if (msgObj.toolUseResult && msgObj.toolUseResult.file) {
    msgObj.toolUseResult = { type: msgObj.toolUseResult.type, cleared: true };
  }
  return msgObj;
}

// Find all assistant message indexes
const assistantIndexes = [];
lines.forEach((ln, i) => {
  if (i === 0) return;
  try {
    const { type } = JSON.parse(ln);
    if (type === "assistant") assistantIndexes.push(i);
  } catch {}
});

// Build output with adaptive message count
function buildOutput(keepCount) {
  let cutFrom = 0;
  if (assistantIndexes.length > keepCount) {
    cutFrom = assistantIndexes[assistantIndexes.length - keepCount];
  }

  const outLines = [lines[0]]; // keep header
  let dropped = 0;

  lines.forEach((ln, i) => {
    if (i === 0) return;
    let parsed = null;
    let isMsg = false;
    try {
      parsed = JSON.parse(ln);
      isMsg = MSG_TYPES.has(parsed.type);
    } catch {}

    if (isMsg) {
      if (i >= cutFrom) {
        // Clear large content (tool results, documents) to reduce size
        const cleared = clearLargeContent(parsed);
        outLines.push(JSON.stringify(cleared));
      } else {
        dropped++;
      }
    } else {
      if (i >= cutFrom) outLines.push(ln);
    }
  });

  return { outLines, dropped };
}

// Try with initial keep count, reduce if too large
let result = buildOutput(keep);
let output = result.outLines.join("\n");

while (output.length > MAX_OUTPUT_BYTES && keep > MIN_MESSAGES) {
  keep -= 2;
  result = buildOutput(keep);
  output = result.outLines.join("\n");
}

if (result.dropped > 0 || output.length <= MAX_OUTPUT_BYTES) {
  const sizeKB = Math.round(output.length / 1024);
  console.error(`(Pruned: kept last ${keep} assistant messages, dropped ${result.dropped} earlier, ${sizeKB}KB output, content cleared)`);
}
console.log(output);
' "$SESSION_FILE" "$MAX_ASSISTANT_MSGS" > "$TEMP_SESSION"

cat "$PROJECT_ROOT/prompts/analyze-transcript-for-handoff.md" > "$TEMP_PROMPT"
echo "" >> "$TEMP_PROMPT"
echo "---" >> "$TEMP_PROMPT"
echo "" >> "$TEMP_PROMPT"
echo "## Session Transcript" >> "$TEMP_PROMPT"
echo "" >> "$TEMP_PROMPT"
cat "$TEMP_SESSION" >> "$TEMP_PROMPT"

echo "Analyzing session $SESSION_ID..."

# Run claude --print, piping the prompt via stdin
cat "$TEMP_PROMPT" | claude --print > "$HANDOFF_FILE"

echo "Handoff saved to: $HANDOFF_FILE"
echo ""
echo "Starting fresh session with handoff context..."

# Build resume prompt with handoff content
TEMP_RESUME=$(mktemp)
trap "rm -f $TEMP_PROMPT $TEMP_SESSION $TEMP_RESUME" EXIT

cat "$PROJECT_ROOT/prompts/resume-from-handoff.md" > "$TEMP_RESUME"
cat "$HANDOFF_FILE" >> "$TEMP_RESUME"

# Append user message if provided
if [ -n "$USER_MESSAGE" ]; then
    echo "" >> "$TEMP_RESUME"
    echo "---" >> "$TEMP_RESUME"
    echo "" >> "$TEMP_RESUME"
    echo "## Additional Instructions" >> "$TEMP_RESUME"
    echo "" >> "$TEMP_RESUME"
    echo "$USER_MESSAGE" >> "$TEMP_RESUME"
fi

# Launch fresh interactive session with handoff as initial prompt
if [ "$SAFE_MODE" = true ]; then
    claude "$(cat "$TEMP_RESUME")"
else
    claude --dangerously-skip-permissions "$(cat "$TEMP_RESUME")"
fi
